# -*- coding: utf-8 -*-
"""CKM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FTaEJuhm6TMHe6mI2JPOu3IqXQR1ieFK

# **Precision Measurements of CKM Matrix elements (Flavor Physics)**
This work is a continuation of the REYES 2023 Hadronic Physics Project. In the previous study, we extracted the values of $|V_{ub}|$ and the parameter $\alpha$. In the present work, we aim to determine the uncertainties associated with $|V_{ub}|$ and $ \alpha$ for a more precise measurement. Additionally, we extract the value of the form factor normalization $ f_{+}(0)$, along with its corresponding uncertainty.
"""

################################################################################
#                              IMPORTING LIBRARIES                             #
################################################################################
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import quad

# Defining the constants
f_plus0 = 0.261
mb_star = 5.324

"Defining the model 1"
def f1_plus(q_2):
    f1_plus = f_plus0 / (1 - q_2 / mb_star**2)
    return f1_plus

# Create an array for q_2 values from 0 to 30
q_2 = np.linspace(1, 26, 100)  # 100 points between 0 and 30

# Plot the graph
plt.plot(q_2, f1_plus(q_2), linewidth=0.5)
plt.ylim(0, 12)
plt.xlim(0, 30)

# Add labels and title
plt.xlabel('$q^2[Gev^2]$')
plt.ylabel('$f_{+}(q^2)$')
plt.title('$f_{+}(q^2)$ vs. $q^2$ using Model 1')
plt.grid()

# Display the plot
plt.show()

# Defining constants
f_plus0 = 0.261
mb_star = 5.324
alpha = 0.54

"Defining the Model 2"
def f2_plus(q_2):
    f2_plus = (f_plus0) / ((1 - q_2 / mb_star**2) * (1 - alpha * q_2 / mb_star**2))
    return f2_plus

# Create an array for q_2 values from 0 to 30 (same as before)
q_2 = np.linspace(1, 26, 100)

# Plot the graph
plt.plot(q_2, f2_plus(q_2), linewidth=0.5)
plt.ylim(0, 12)
plt.xlim(0, 30)

# Add labels and title
plt.xlabel('$q^2[Gev^2]$')
plt.ylabel('$f_{+}(q^2)$')
plt.title('$f_{+}(q^2)$ vs. $q^2$ using Model 2')
plt.grid()

# Display the plot
plt.show()

"Plotting both of the models together"

# Plot the first function f1_plus
plt.plot(q_2, f1_plus(q_2), label='Model 1', linewidth=0.5)

# Plot the second function f2_plus
plt.plot(q_2, f2_plus(q_2), label='Model 2', linewidth=0.5)

# Set y-axis limits
plt.ylim(0, 12)

# Set x-axis limits
plt.xlim(0, 30)

# Add labels and title
plt.xlabel('$q^2[Gev^2]$')
plt.ylabel('$f_{+}(q^2)$')
plt.title('$f_{+}(q^2)$ vs. $q^2$')

# Show legend to differentiate the two functions
plt.legend()
plt.grid()
# Display the plot
plt.show()

#Defining the constants

br=1.50e-4
gamma_B0= 4.33e-13
GF= 1.166e-5
mb_Gev= 5.27966
mpi_Gev= 0.13957
ml_Mev= 0.511

def lambda_xyz(x, y, z):
    return x**2 + y**2 + z**2 - 2*(x*y + x*z + y*z)

#Performing integration

def integrand1(q_2):
    term1= (GF**2 *np.sqrt(lambda_xyz(mb_Gev**2, mpi_Gev**2, q_2))) / (128*mb_Gev**3 *np.pi**3 *q_2)
    term2= (1-(ml_Mev * 10**(-3))**2 / q_2)**2
    term3= (2*q_2/3) * lambda_xyz(mb_Gev**2, mpi_Gev**2, q_2) * (1+((ml_Mev*10**(-3))**2/(2*q_2)))*np.abs(f1_plus(q_2))**2
    return term1* term2* term3

def integrand2(q_2):
    term1= (GF**2 *np.sqrt(lambda_xyz(mb_Gev**2, mpi_Gev**2, q_2))) / (128*mb_Gev**3 *np.pi**3 *q_2)
    term2= (1-(ml_Mev * 10**(-3))**2 / q_2)**2
    term3= (2*q_2/3) * lambda_xyz(mb_Gev**2, mpi_Gev**2, q_2) * (1+((ml_Mev*10**(-3))**2/(2*q_2)))*np.abs(f2_plus(q_2))**2
    return term1* term2* term3

# Integration limits
lower_lim = 0
upper_lim = (mb_Gev - mpi_Gev)**2

# Integral Terms
result1, error1 = quad(integrand1, lower_lim, upper_lim)
result2, error2 = quad(integrand2, lower_lim, upper_lim)

# V_ub
v_ub1 = np.sqrt(br * gamma_B0 / result1)
print("Model 1:", v_ub1)
v_ub2 = np.sqrt(br * gamma_B0 / result2)
print("Model 2:", v_ub2)

"Plotting for Model 1"

def dB_dq_2_1(q_2):
    # Initialize empty array to store the result
    result = np.zeros_like(q_2)

    # Loop through each q_2 value and calculate dB/dq_2
    for i, q in enumerate(q_2):
        term1 = (GF**2 *np.abs(v_ub1)**2* np.sqrt(lambda_xyz(mb_Gev**2, mpi_Gev**2, q))) / (128*gamma_B0 * mb_Gev**3 * np.pi**3 * q)
        term2 = (1 - (ml_Mev * 10**(-3))**2 / q)**2
        term3 = (2 * q / 3) * lambda_xyz(mb_Gev**2, mpi_Gev**2, q) * (1 + ((ml_Mev * 10**(-3))**2 / (2 * q)))**2 * np.abs(f1_plus(q))**2
        result[i] = term1 * term2 * term3
    return result

# Calculate dB/dq_2 values
dB_dq_2_value_1 = dB_dq_2_1(q_2)
print(dB_dq_2_value_1)
dB_dq_2_values_1_1= dB_dq_2_value_1*1e6

plt.plot(q_2, dB_dq_2_values_1_1)
plt.xlabel('$q^2[Gev^2]$')
plt.ylabel(r'$\frac{{dB}}{{dq^2}} \times 10^6[Gev^2]$')
plt.title(r'$\frac{{dB}}{{dq^2}}$ vs. $q^2$')
plt.grid()
plt.show()

"Plotting for Model 2"

def dB_dq_2(q_2):
    # Initialize empty array to store the result
    result = np.zeros_like(q_2)

    # Loop through each q_2 value and calculate dB/dq_2
    for i, q in enumerate(q_2):
        term1 = (GF**2 *np.abs(v_ub2)**2* np.sqrt(lambda_xyz(mb_Gev**2, mpi_Gev**2, q))) / (128*gamma_B0 * mb_Gev**3 * np.pi**3 * q)
        term2 = (1 - (ml_Mev * 10**(-3))**2 / q)**2
        term3 = (2 * q / 3) * lambda_xyz(mb_Gev**2, mpi_Gev**2, q) * (1 + ((ml_Mev * 10**(-3))**2 / (2 * q)))**2 * np.abs(f2_plus(q))**2
        result[i] = term1 * term2 * term3

    return result

# Calculate dB/dq_2 values
dB_dq_2_values = dB_dq_2(q_2)
print(dB_dq_2_values)
dB_dq_2_values_1= dB_dq_2_values*1e6

plt.plot(q_2, dB_dq_2_values_1)
plt.xlabel('$q^2[Gev^2]$')
plt.ylabel(r'$\frac{{dB}}{{dq^2}} \times 10^6[Gev^2]$')
plt.title(r'$\frac{{dB}}{{dq^2}}$ vs. $q^2$')
plt.grid()
plt.show()

# Provided data points
data_text = """{1, 7.2, 0.7000000000000001}
{3, 7.140000000000001, 0.45999999999999996}
{5, 6.7, 0.39}
{7, 7.56, 0.43}
{9, 6.440000000000001, 0.43}
{11, 7.170000000000001, 0.45999999999999996}
{13, 6.670000000000001, 0.47000000000000003}
{15, 6.33, 0.48}
{17, 6.2, 0.44000000000000006}
{19, 4.32, 0.43}
{21, 4.25, 0.41}
{23, 3.4000000000000004, 0.42000000000000004}
{25.2, 1.17, 0.26}"""

# Split the data into lines
lines = data_text.split("\n")

# Clean each line by removing the curly braces
cleaned_data = [line.replace("{", "").replace("}", "") for line in lines]

# Convert the data to float arrays
q_2_values = np.array([float(line.split(",")[0]) for line in cleaned_data])
db_dq_2_values = np.array([float(line.split(",")[1]) for line in cleaned_data])
err = np.array([float(line.split(",")[2]) for line in cleaned_data])
print(q_2_values)

"Defining the constants"
f_plus0 = 0.261
mb_star = 5.324
gamma_B0 = 4.33e-13
GF = 1.166e-5
mb_Gev = 5.27966
mpi_Gev = 0.13957
ml_Mev = 0.511

def lambda_xyz(x, y, z):
    return x**2 + y**2 + z**2 - 2*(x*y + x*z + y*z)

"""Performing Chi-Square Test to extract the optimal value of Vub and alpha."""

def f_plus2(q_2):
    f_plus = f_plus0 / ((1 - q_2 / mb_star**2) * (1 - alpha * q_2 / mb_star**2))
    return f_plus

def dB_dq_2(q_2_values, alpha, v_ub):
    result = np.zeros_like(q_2_values)
    for i, q in enumerate(q_2_values):
        term1 = (GF**2 * np.abs(v_ub)**2 * np.sqrt(lambda_xyz(mb_Gev**2, mpi_Gev**2, q))) / (128 * gamma_B0 * mb_Gev**3 * np.pi**3 * q)
        term2 = (1 - (ml_Mev * 10**(-3))**2 / q)**2
        term3 = (2 * q / 3) * lambda_xyz(mb_Gev**2, mpi_Gev**2, q) * (1 + ((ml_Mev * 10**(-3))**2 / (2 * q))) * np.abs(f_plus2(q))**2
        result[i] = term1 * term2 * term3
    return result*10**6

"Performing Chi-Square Fitting"

# Grid search over alpha and v_ub
x = np.linspace(0, 1, 40)
y = np.linspace(0.001, 0.005, 40)
chi_square_values = np.zeros((40, 40))

for alpha_index, alpha in enumerate(x):
    for v_ub_index, v_ub in enumerate(y):
        # Calculate dB/dq_2 values for current alpha and v_ub
        dB_dq_2_values_model = dB_dq_2(q_2_values, alpha, v_ub)

        # Calculate chi-square for the current model and ignore the third data point
        chi_square = np.sum(((db_dq_2_values[:13]-dB_dq_2_values_model[:13])/err[:13])**2)

        # Store the chi-square value in the 2D array
        chi_square_values[alpha_index, v_ub_index] = chi_square

# Find the minimum chi-square value and its corresponding indices
min_chi_square = np.min(chi_square_values)
optimal_alpha_index, optimal_v_ub_index = np.unravel_index(np.argmin(chi_square_values), chi_square_values.shape)

# Get the corresponding optimal_alpha and optimal_v_ub using the index
optimal_alpha = x[optimal_alpha_index]
optimal_v_ub = y[optimal_v_ub_index]

# Print the results
print("\n Minimum Value of χ² is:", min_chi_square)
print("Optimal Vub value corresponding to minimum chi-square:", optimal_v_ub)
print("Optimal alpha value corresponding to minimum chi-square:", optimal_alpha)
dof = 11 #calculated using no of data points-parameters
goodness_of_fit= min_chi_square/dof
print("Goodness of fit:",goodness_of_fit)
#print(dB_dq_2(q_2_values, alpha, v_ub))

"""Extracting the uncertainties associated with Vub and alpha using covariance matrix"""

import scipy.optimize as opt

# Defining the constants
f_plus0 = 0.261
mb_star = 5.324
gamma_B0 = 4.33e-13
GF = 1.166e-5
mb_Gev = 5.27966
mpi_Gev = 0.13957
ml_Mev = 0.511

# Define the lambda_xyz function
def lambda_xyz(x, y, z):
    return x**2 + y**2 + z**2 - 2*(x*y + x*z + y*z)

# Define the f_plus2 function
def f_plus2(X, alpha):
    f_plus = f_plus0 / ((1 - X / mb_star**2) * (1 - alpha * X / mb_star**2))
    return f_plus

# Define the act function with alpha as a parameter
def act(X, V, alpha):
    term1 = (GF**2 * abs(V)**2 * (lambda_xyz(mb_Gev**2, mpi_Gev**2, X))**0.5) / (128 * gamma_B0 * mb_Gev**3 * np.pi**3 * X)
    term2 = (1 - (ml_Mev * 1e-3)**2 / X)**2
    term3 = (2 * X / 3) * lambda_xyz(mb_Gev**2, mpi_Gev**2, X) * (1 + (ml_Mev * 1e-3)**2 / (2 * X)) * abs(f_plus2(X, alpha))**2
    return term1 * term2 * term3 * 1e6

# Define the data
pts = np.array([1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25.2])
B_datapoints = np.array([7.2, 7.140000000000001, 6.7, 7.56, 6.440000000000001, 7.170000000000001, 6.670000000000001, 6.33, 6.2, 4.32, 4.25, 3.4000000000000004, 1.17])
uncertainties = np.array([0.7000000000000001, 0.45999999999999996, 0.39, 0.43, 0.43, 0.45999999999999996, 0.47000000000000003, 0.48, 0.44000000000000006, 0.43, 0.41, 0.42000000000000004, 0.26])

# Perform curve fitting to find optimal alpha and V
minvals, covariance = opt.curve_fit(act, pts, B_datapoints)

# Extract the optimal values of alpha and V
optimal_V, optimal_alpha = minvals
v_ub_err = covariance[0][0]**(1/2)
alpha_err = covariance[1][1]**(1/2)

# Print the results
print("Optimal alpha value:", optimal_alpha)
print("Delta alpha=" ,alpha_err)
print("Optimal V value:", optimal_V)
print("Delta v=", v_ub_err)
print("Covariance matrix:")
print(covariance)

"""Several delta values were tested to identify the value that yields the most optimal alpha."""

# List of delta values to test
delta_values = np.array([0.01, 0.02, 0.05, 0.06, 0.07, 0.1])

def f_plus2(q_2, alpha):
    f_plus = f_plus0 / ((1 - q_2 / mb_star**2) * (1 - alpha * q_2 / mb_star**2))
    return f_plus

def dB_dq_2(q_2_values, alpha, v_ub):
    result = np.zeros_like(q_2_values)
    for i, q in enumerate(q_2_values):
        term1 = (GF**2 * np.abs(v_ub)**2 * np.sqrt(lambda_xyz(mb_Gev**2, mpi_Gev**2, q))) / (128 * gamma_B0 * mb_Gev**3 * np.pi**3 * q)
        term2 = (1 - (ml_Mev * 10**(-3))**2 / q)**2
        term3 = (2 * q / 3) * lambda_xyz(mb_Gev**2, mpi_Gev**2, q) * (1 + ((ml_Mev * 10**(-3))**2 / (2 * q))) * np.abs(f_plus2(q, alpha))**2
        result[i] = term1 * term2 * term3
    return result*10**6

# Initialize arrays to store minimum chi-square values and optimal alpha values
min_chi_square_values = np.zeros(len(delta_values))
optimal_alpha_values = np.zeros(len(delta_values))

# Loop over delta values
for delta_index, delta in enumerate(delta_values):
    # Calculate v_ub for the current delta value
    v_ub = 3.666666666666667 * 10**(-3) + delta * 10**(-3)

    # Grid search over alpha
    x = np.linspace(0, 1, 40)
    chi_square_values = np.zeros_like(x)  # Initialize an array to store chi-square values

    for alpha_index, alpha in enumerate(x):
        # Calculate dB/dq_2 values for current alpha
        dB_dq_2_values_model = dB_dq_2(q_2_values, alpha, v_ub)

        # Calculate chi-square for the current model and ignore the third data point
        chi_square = np.sum(((db_dq_2_values[:13] - dB_dq_2_values_model[:13]) / err[:13])**2)

        # Store the chi-square value in the array
        chi_square_values[alpha_index] = chi_square

    # Find the index of the minimum chi-square value
    optimal_alpha_index = np.argmin(chi_square_values)

    # Get the corresponding optimal_alpha using the index
    optimal_alpha = x[optimal_alpha_index]

    # Store the minimum chi-square and optimal alpha values
    min_chi_square_values[delta_index] = np.min(chi_square_values)
    optimal_alpha_values[delta_index] = optimal_alpha

    # Print the results for the current delta value
    print(f"For delta = {delta}")
    print(f"Optimal alpha value corresponding to minimum chi-square: {optimal_alpha}")
    print(f"Minimum Value of χ² is: {min_chi_square_values[delta_index]}")
    print()

# Print the arrays of minimum chi-square values and optimal alpha values
#print("Min Chi Square Values:", min_chi_square_values)
#print("Optimal Alpha Values:", optimal_alpha_values)

import scipy.optimize as optimize

# Define bounds for delta (e.g., between 0 and 1)
delta_bounds = (0.0, 1.0)

# Define a function that calculates the chi-square for a given delta value
def chi_square_for_delta(delta):
    # Calculate dB/dq_2 values for the optimal alpha and the current delta
    dB_dq_2_values_model = dB_dq_2(q_2_values, optimal_alpha, delta)

    # Calculate chi-square for the current model and ignore the third data point
    chi_square = np.sum(((db_dq_2_values[:13] - dB_dq_2_values_model[:13]) / err[:13])**2)

    return chi_square

# Perform a one-dimensional search for delta with bounds and an initial guess of 0.1
initial_delta_guess = 0.1 # Initial guess for delta
result = optimize.minimize(chi_square_for_delta, initial_delta_guess, bounds=[delta_bounds], method='L-BFGS-B')

# Extract the optimal delta value from the result
optimal_delta = result.x[0]

# Print the optimal delta value
print("Optimal delta value associated with the optimal alpha:", optimal_delta)

import scipy.stats as stats

# Define the range of alpha values around the optimal value
alpha_range = np.linspace(optimal_alpha - 0.1, optimal_alpha + 0.1, 40)  # Adjust the range as needed

# Initialize arrays to store results
chi_square_values_alpha = np.zeros_like(alpha_range)

# Calculate chi-square values for different alpha values
for alpha_index, alpha_value in enumerate(alpha_range):
    # Calculate dB/dq_2 values for the current alpha value and optimal_v_ub
    dB_dq_2_values_model = dB_dq_2(q_2_values, alpha_value, optimal_v_ub)

    # Calculate chi-square for the current model and ignore the third data point
    chi_square = np.sum(((db_dq_2_values[:13] - dB_dq_2_values_model[:13]) / err[:13])**2)

    # Store the chi-square value in the array
    chi_square_values_alpha[alpha_index] = chi_square

# Calculate the degrees of freedom (number of data points - number of parameters estimated)
dof = len(q_2_values) - 11  # Adjust this based on your specific data and model

# Set the significance level (alpha) for the chi-square test
significance_level = 0.05  # Adjust as needed

# Find the critical chi-square value for the given significance level and degrees of freedom
critical_chi_square = stats.chi2.ppf(1 - significance_level, dof)

# Compare the calculated chi-square values to the critical value
rejected_alpha_indices = np.where(chi_square_values_alpha > critical_chi_square)

# Get the alpha values corresponding to rejected hypotheses (where H0 is rejected)
rejected_alpha_values = alpha_range[rejected_alpha_indices]

# Calculate the confidence interval for delta based on rejected alpha values
delta_lower = optimal_alpha - np.max(np.abs(rejected_alpha_values - optimal_alpha))
delta_upper = optimal_alpha + np.max(np.abs(rejected_alpha_values - optimal_alpha))

# Report the results
print("Optimal alpha:", optimal_alpha)
print("Critical chi-square value:", critical_chi_square)
print("Rejected alpha values:", rejected_alpha_values)
print("Confidence interval for delta:", delta_lower, "-", delta_upper)

# Provided data points
data_text1 = """{18, 1.102120460507618, 0.04357790910065373}
{22, 1.9639695090841516, 0.05361204576216541}
{26, 5.848241251224902, 0.22631557294259566}"""

# Split the data into lines
lines = data_text1.split("\n")

# Clean each line by removing the curly braces
cleaned_data = [line.replace("{", "").replace("}", "") for line in lines]

# Convert the data to float arrays
q_2_values2 = np.array([float(line.split(",")[0]) for line in cleaned_data])
f_plus_q2 = np.array([float(line.split(",")[1]) for line in cleaned_data])
err2 = np.array([float(line.split(",")[2]) for line in cleaned_data])
print(q_2_values2)
print(f_plus_q2)
print(err2)

"""Now similarly doing precision measurements for quantity $f_{+}(0)$"""

mb_star = 5.324

"Defining the Model 2"
def f_plus_q21(q_2_values2, alpha):
    f_plus_q21 = (f_plus0) / ((1 - q_2_values2/ mb_star**2) * (1 - alpha * q_2 / mb_star**2))
    return f_plus_q21

def f_plus_q21(q_2_values2, alpha, f_plus0, mb_star):
    return (f_plus0) / ((1 - q_2_values2 / mb_star**2) * (1 - alpha * q_2_values2 / mb_star**2))

x = np.linspace(0, 1, 40)
y = np.linspace(0, 1, 40)
chi_square_values = np.zeros((40, 40))

for alpha_index, alpha in enumerate(x):
    for f_plus0_index, f_plus0 in enumerate(y):
        f_plus_q21_values = f_plus_q21(q_2_values2, alpha, f_plus0, mb_star)

        # Calculate chi-square for the current model
        chi_square = np.sum(((f_plus_q2 - f_plus_q21_values) / err2)**2)

        # Store the chi-square value in the 2D array
        chi_square_values[alpha_index, f_plus0_index] = chi_square

# Find the minimum chi-square value and its corresponding indices
min_chi_square = np.min(chi_square_values)
optimal_alpha_index, optimal_f_plus0_index = np.unravel_index(np.argmin(chi_square_values), chi_square_values.shape)

# Get the corresponding optimal_f_plus0 and optimal_alpha using the index
optimal_f_plus0 = y[optimal_f_plus0_index]
optimal_alpha = x[optimal_alpha_index]

# Print the results
print("\nMinimum Value of χ² is:", min_chi_square)
print("Optimal f_plus0 value corresponding to minimum chi-square:", optimal_f_plus0)
print("Optimal Alpha corresponding to minimum chi-square:", optimal_alpha)

import numpy as np

# Provided data points
data_text1 = """{18, 1.102120460507618, 0.04357790910065373}
{22, 1.9639695090841516, 0.05361204576216541}
{26, 5.848241251224902, 0.22631557294259566}"""

# Split the data into lines
lines = data_text1.split("\n")

# Clean each line by removing the curly braces
cleaned_data = [line.replace("{", "").replace("}", "") for line in lines]

# Convert the data to float arrays
q_2_values2 = np.array([float(line.split(",")[0]) for line in cleaned_data])
f_plus_q2 = np.array([float(line.split(",")[1]) for line in cleaned_data])
err2 = np.array([float(line.split(",")[2]) for line in cleaned_data])

# Constants
mb_star = 5.324
fixed_alpha = 0.55  # Fixed value of alpha

# Define the model function with fixed alpha
def f_plus_q21_fixed_alpha(q_2_values2, f_plus0, mb_star):
    return (f_plus0) / ((1 - q_2_values2 / mb_star**2) * (1 - fixed_alpha * q_2_values2 / mb_star**2))

# Performing Chi-Square Fitting to find f_plus0 with fixed alpha

# Grid search over f_plus0
x = np.linspace(0, 1, 40)
chi_square_values = np.zeros(40)

for f_plus0_index, f_plus0 in enumerate(x):
    f_plus_q21_values = f_plus_q21_fixed_alpha(q_2_values2, f_plus0, mb_star)

    # Calculate chi-square for the current model
    chi_square = np.sum(((f_plus_q2 - f_plus_q21_values) / err2)**2)

    # Store the chi-square value in the array
    chi_square_values[f_plus0_index] = chi_square

# Find the minimum chi-square value and its corresponding index
min_chi_square = np.min(chi_square_values)
optimal_f_plus0_index = np.argmin(chi_square_values)

# Get the corresponding optimal_f_plus0 using the index
optimal_f_plus0 = x[optimal_f_plus0_index]

# Print the results
print("\nMinimum Value of χ² is:", min_chi_square)
print("Optimal f_plus0 value corresponding to minimum chi-square:", optimal_f_plus0)

import scipy.optimize as opt

mb_star = 5.324

# Define the model function
def func(x, f_plus0):
    f1 = (f_plus0) / ((1 - x / mb_star**2) * (1 - 0.54* x / mb_star**2))
    return f1

points = np.array([18, 22, 26])
f_data = np.array([1.102120460507618, 1.9639695090841516, 5.848241251224902])
error = np.array([0.04357790910065373, 0.05361204576216541, 0.22631557294259566])

# Perform curve fitting to find optimal f_plus0
minvals, covariance = opt.curve_fit(func, points, f_data)

# Extract the optimal value of f_plus0 from minvals
optimal_f_plus0 = minvals[0]

# Print the results
print("Optimal f_plus0 value:", optimal_f_plus0)
print("Delta f_plus0:", covariance[0][0]**(1/2))

import matplotlib.pyplot as plt
plt.scatter(points, f_data)
plt.plot(points, f_data, linestyle= 'dashed')
plt.xlim(0,28)
plt.ylim(0,7)
plt.xlabel('$q^2[Gev^2]$')
plt.ylabel('$f_{+}(q^2)$')
plt.title('$f_{+}(q^2)$ vs. $q^2$')
plt.grid()

q2_values = np.array([1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25.2])
db_points = np.array([7.2,  7.14, 6.7,  7.56, 6.44, 7.17, 6.67, 6.33, 6.2,  4.32, 4.25, 3.4,  1.17])
e = np.array([0.7,  0.46, 0.39, 0.43, 0.43, 0.46, 0.47, 0.48, 0.44, 0.43, 0.41, 0.42, 0.26])
f_plus0 = 0.261
mb_star = 5.324
gamma_B0 = 4.33e-13
GF = 1.166e-5
mb_Gev = 5.27966
mpi_Gev = 0.13957
ml_Mev = 0.511

def lambda_xyz(x, y, z):
    return x**2 + y**2 + z**2 - 2*(x*y + x*z + y*z)

def func(X, alpha):
    f1 = (optimal_f_plus0) / ((1 - X / mb_star**2) * (1 - alpha* X/ mb_star**2))
    return f1

def decay(X, V, alpha):
    term1 = (GF**2 * abs(V)**2 * (lambda_xyz(mb_Gev**2, mpi_Gev**2, X))**0.5) / (128 * gamma_B0 * mb_Gev**3 * np.pi**3 * X)
    term2 = (1 - (ml_Mev * 1e-3)**2 / X)**2
    term3 = (2 * X / 3) * lambda_xyz(mb_Gev**2, mpi_Gev**2, X) * (1 + (ml_Mev * 1e-3)**2 / (2 * X)) * abs(func(X, alpha))**2
    return term1 * term2 * term3 * 1e6

minvals, covariance = opt.curve_fit(decay, q2_values, db_points)
optimal_V, optimal_alpha = minvals
v_ub_err = covariance[0][0]**(1/2)
alpha_err = covariance[1][1]**(1/2)

a,b = minvals
curve =[]
for i in q2_values:
  C= decay(i,a,b)
  curve.append(C)
plt.errorbar(q2_values, db_points, yerr= e, fmt='o')
plt.plot(q2_values, curve)
plt.show()
# Print the results
print("Optimal alpha value:", optimal_alpha)
print("Delta alpha=" ,alpha_err)
print("Optimal V value:", optimal_V)
print("Delta v=", v_ub_err)
print("Covariance matrix:")
print(covariance)

"""Finding the uncertainties associated with the three quantities"""

from scipy.optimize import curve_fit
f_data = np.array([1.102120460507618, 1.9639695090841516, 5.848241251224902])
comboY = np.append(db_points, f_data)
h = np.array([18,22,26])  # X-axis values of QCD data points
comboX = np.append(q2_values, h)
def mod2(x, alpha, f): # not all parameters are used here
        return f/((1-(x/mb_star**2))*(1-(alpha*x)/mb_star**2))
def comboFunc(comboData, V, alpha, f):
    # single data set passed in, extract separate data
    extract1 = comboData[:len(q2_values)] # first data
    extract2 = comboData[-len(f_data):] # second data
    result1 = decay(extract1, V, alpha)
    result2 = mod2(extract2, alpha, f)
    return np.append(result1, result2)
# curve fit the combined data to the combined function
fittedParameters, pcov = curve_fit(comboFunc, comboX, comboY)
# values for display of fitted function
A,B,C = fittedParameters
print(fittedParameters)
#print(pcov)
print('Error values of parameters:')
print('Error in V_ub is:',np.sqrt(pcov[0,0]))
print('Error in alpha is:',np.sqrt(pcov[1,1]))
print('Error in F(0) is:',np.sqrt(pcov[2,2]))

#covariance matrix corresponding to form factor
fcov= np.array([0.00189905,0.00287428,0.0512193])
qsq_values= np.array([1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25.2])
db_data= np.array([72.,71.4, 67., 75.6, 64.4, 71.7, 66.7, 63.3, 62., 43.2, 42.5, 34., 11.7,])
error_valuess= np.array([7., 4.6,3.9, 4.3, 4.3, 4.6, 4.7, 4.8, 4.4, 4.3, 4.1, 4.2, 2.6])
dcov=np.array([49.091, 21.487, 15.489,18.2,18.124,21.34,21.875,23.04,19.798,18.0629,16.99,17.774,6.516])